# Implementation Plan: RAG Chatbot - OpenAI ChatKit Integration

**Branch**: `004-rag-chatbot-openai` | **Date**: 2025-11-30 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `specs/004-rag-chatbot-openai/spec.md`

## Summary
This plan outlines the steps to build a production-ready RAG chatbot using OpenAI Agents/ChatKit SDKs that answers questions about the Physical AI & Humanoid Robotics book content. It covers backend architecture (FastAPI, Postgres, Qdrant, OpenAI Agents), frontend integration (Docusaurus React components), deployment, error handling, and testing.

## Technical Context
**Language/Version**: Python 3.11+, TypeScript, JavaScript.
**Primary Dependencies**: FastAPI, Uvicorn, OpenAI (with Agents SDK support), `openai-agents` or `chatkit-sdk`, `qdrant-client`, `psycopg2-binary`, `python-dotenv`, `pydantic`, Docusaurus, React.
**Storage**: Neon Serverless Postgres (for chat sessions, messages, agent memory), Qdrant Cloud (for book content vector embeddings).
**Testing**: Unit tests for backend logic, integration tests for API endpoints, E2E tests for frontend functionality. Agent testing for initialization, tool calling, multi-turn conversations, text selection, and citation accuracy.
**Target Platform**: Web (FastAPI backend, Docusaurus React frontend).
**Project Type**: Full-stack web application with AI integration.
**Performance Goals**: Fast response times with streaming, perceived <2 seconds for initial response.
**Constraints**: Production-ready code, secure environment variable management, multi-turn conversation support, context-aware responses, clickable source citations, transparent agent processing, zero CORS/connection errors.
**Scale/Scope**: Single chatbot instance, comprehensive book content as data source, text selection feature.

## Constitution Check
*GATE: All principles must be adhered to during implementation.*

- [x] **I. Production-Ready Code**: All backend and frontend code must include proper error handling, logging, and follow best practices for production deployment.
- [x] **II. TypeScript Type Safety**: Frontend components will utilize TypeScript for strong type safety. Backend Pydantic models will ensure data validation.
- [x] **III. Mobile-Responsive Design**: The chat UI must be fully responsive and functional on mobile devices.
- [x] **IV. Clear Documentation**: API endpoints will be self-documented via OpenAPI, and code will have inline comments where necessary.
- [x] **V. Modular & Reusable Components**: Frontend and backend will be designed with modular components for scalability and maintainability.
- [x] **VI. RESTful API Design**: The backend will expose RESTful API endpoints as specified, with clear request/response contracts.
- [x] **VII. Secure Environment Management**: Environment variables will be used exclusively for sensitive data, never hardcoded or committed. CORS will be properly configured.

## Project Structure

### Documentation (this feature)
```text
specs/004-rag-chatbot-openai/
├── plan.md              # This file
├── research.md          # Technology decisions for RAG Chatbot
├── data-model.md        # Database schemas (Postgres, Qdrant)
├── contracts/           # OpenAPI specification for API endpoints
├── quickstart.md        # Basic setup guide for backend and frontend
└── tasks.md             # To be generated by /sp.tasks
```

### Source Code (repository root)
The RAG Chatbot will consist of a separate `backend` directory for the FastAPI application and frontend components integrated into the existing `physical-ai-book` Docusaurus project.

```text
.
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── models/            # Pydantic/SQLAlchemy models
│   │   ├── services/          # Business logic, Qdrant/Postgres clients, OpenAI Agent wrapper
│   │   ├── api/               # FastAPI routers for endpoints
│   │   └── config.py          # Environment variable loading
│   ├── requirements.txt
│   ├── .env.example
│   └── Dockerfile             # (Optional) For containerization
├── physical-ai-book/          # Existing Docusaurus project
│   └── src/theme/
│       └── Root.tsx           # For ChatButton/ChatWindow integration
│       └── components/
│           ├── ChatButton.tsx
│           ├── ChatWindow.tsx
│           ├── MessageList.tsx
│           ├── MessageInput.tsx
│           ├── TextSelectionHandler.tsx
│           ├── AgentThinking.tsx
│           └── ChatContext.tsx
└── (other existing Docusaurus files)
```
**Structure Decision**: A separate `backend` directory is chosen for clarity and independent deployment of the FastAPI application. Frontend components will be integrated directly into the Docusaurus project structure.

## Implementation Phases

### PHASE 1: BACKEND SETUP (Estimated Time: 30 mins)
- **Task**: Create `backend` project structure.
- **Task**: Setup Python virtual environment.
- **Task**: Install all dependencies (FastAPI, OpenAI SDK, Qdrant, Psycopg2, etc.).
- **Task**: Create `.env` file template and `config.py` for environment variables.
- **Task**: Setup basic FastAPI app with CORS.
- **Deliverables**: Backend project scaffolded, dependencies installed, basic app runnable.
- **Success Criteria**: `backend/app/main.py` runs with `uvicorn`, shows a basic "Hello World", and CORS is configured.

### PHASE 2: DATABASE SETUP (Estimated Time: 30 mins)
- **Task**: Configure Neon Postgres connection using environment variables.
- **Task**: Define database schema (chat_sessions, messages, agent_memory) in `backend/app/models/`.
- **Task**: Write database integration logic (e.g., using `psycopg2` directly or an ORM like `SQLAlchemy`).
- **Task**: Test database connection and table creation/insertion.
- **Deliverables**: Database models defined, connection established, tables created in Postgres.
- **Success Criteria**: Backend can connect to Neon Postgres, and CRUD operations on `chat_sessions` and `messages` tables are successful.

### PHASE 3: QDRANT VECTOR DB SETUP (Estimated Time: 30 mins)
- **Task**: Connect to Qdrant Cloud using environment variables.
- **Task**: Create `book_content` collection with 1536-dimension vectors.
- **Task**: Write helper functions for Qdrant vector operations (e.g., upsert, search).
- **Task**: Test Qdrant connection and vector operations.
- **Deliverables**: Qdrant client configured, `book_content` collection ready, basic vector operations working.
- **Success Criteria**: Backend can connect to Qdrant, and sample vector upsert/search queries are successful.

### PHASE 4: DOCUMENT EMBEDDING PIPELINE (Estimated Time: 45 mins)
- **Task**: Develop a script/service to read Docusaurus Markdown files (`physical-ai-book/docs/`).
- **Task**: Implement text chunking logic (e.g., using `langchain_text_splitters`).
- **Task**: Generate embeddings for chunks using OpenAI `text-embedding-3-small` model.
- **Task**: Store embeddings and metadata (module, page, title, code_blocks) in Qdrant.
- **Task**: Create `POST /api/embeddings/generate` endpoint to trigger this process.
- **Deliverables**: Fully functional embedding generation and storage in Qdrant.
- **Success Criteria**: `POST /api/embeddings/generate` successfully processes Docusaurus content and populates the Qdrant `book_content` collection.

### PHASE 5: OPENAI AGENT INTEGRATION (Estimated Time: 60 mins)
- **Task**: Initialize OpenAI Agent with specified persona and model (`gpt-4-turbo`).
- **Task**: Define agent tools: `search_book_content(query)`, `get_module_info(module_name)`, `get_code_examples(topic)`.
- **Task**: Implement tool functions to interact with Qdrant and file system (for module/code info).
- **Task**: Test agent initialization and tool calling with sample queries.
- **Deliverables**: Configured OpenAI Agent with functional tools.
- **Success Criteria**: Agent successfully initializes, calls its tools as expected, and returns tool outputs.

### PHASE 6: RAG CHAT ENDPOINT (Estimated Time: 45 mins)
- **Task**: Implement `POST /api/chat` endpoint logic.
- **Task**: Integrate RAG pipeline: User message → Agent analysis → Tool call → Qdrant retrieval → Agent synthesis → Response.
- **Task**: Implement conversation saving to Postgres (`chat_sessions`, `messages`).
- **Task**: Add error handling, retry logic, and handle multi-turn conversation state.
- **Deliverables**: Fully functional chat endpoint providing RAG responses.
- **Success Criteria**: `POST /api/chat` returns accurate, cited, and multi-turn aware responses.

### PHASE 7: TEXT SELECTION ENDPOINT (Estimated Time: 30 mins)
- **Task**: Implement `POST /api/chat/selection` endpoint logic.
- **Task**: Modify agent prompt to prioritize `selected_text`.
- **Task**: Combine `selected_text` with retrieved context for agent synthesis.
- **Deliverables**: Chat endpoint supporting text selection context.
- **Success Criteria**: `POST /api/chat/selection` returns responses focused on the selected text.

### PHASE 8: HEALTH & UTILITY ENDPOINTS (Estimated Time: 15 mins)
- **Task**: Implement `GET /api/health` endpoint (Postgres, Qdrant, OpenAI status).
- **Task**: Implement `GET /api/agent/status` endpoint (agent initialized, tools loaded).
- **Task**: Add structured logging for debugging and monitoring.
- **Deliverables**: Monitoring and status endpoints.
- **Success Criteria**: Both endpoints return correct and comprehensive status information.

### PHASE 9: FRONTEND CHAT BUTTON (Estimated Time: 30 mins)
- **Task**: Create `ChatButton.tsx` (floating, AI badge, click to toggle).
- **Task**: Integrate `ChatButton.tsx` into Docusaurus (`physical-ai-book/src/theme/Root.tsx`).
- **Task**: Style with CSS modules or Tailwind (if integrated).
- **Deliverables**: Functional floating chat button on all Docusaurus pages.
- **Success Criteria**: Chat button appears, animates, and toggles chat window visibility.

### PHASE 10: FRONTEND CHAT WINDOW (Estimated Time: 45 mins)
- **Task**: Create `ChatWindow.tsx` (main chat interface).
- **Task**: Implement slide-in/out animation.
- **Task**: Add header, title, close button, dimensions (400x600px, mobile full screen).
- **Task**: Apply styling.
- **Deliverables**: Functional and styled chat window.
- **Success Criteria**: Chat window opens/closes, displays correctly on desktop/mobile.

### PHASE 11: MESSAGE COMPONENTS (Estimated Time: 45 mins)
- **Task**: Create `MessageList.tsx` (scrollable message area, auto-scroll).
- **Task**: Create `MessageBubble.tsx` (individual messages with roles, timestamps).
- **Task**: Style user/bot messages (alignment, colors, avatar).
- **Task**: Implement clickable source citations.
- **Deliverables**: Visually appealing and functional message display.
- **Success Criteria**: Messages render correctly, sources are clickable, auto-scroll works.

### PHASE 12: MESSAGE INPUT (Estimated Time: 30 mins)
- **Task**: Create `MessageInput.tsx` (text input, send button, Enter/Shift+Enter).
- **Task**: Implement loading state (disable input during API calls).
- **Task**: Add character limit indicator.
- **Deliverables**: User input field for chat.
- **Success Criteria**: Users can type, send messages, and see loading states.

### PHASE 13: AGENT THINKING INDICATOR (Estimated Time: 20 mins)
- **Task**: Create `AgentThinking.tsx` component.
- **Task**: Implement animated dots/spinner.
- **Task**: Display "AI is analyzing the textbook..." text.
- **Task**: Optionally show current tool usage (e.g., "Searching Module 2...").
- **Deliverables**: Clear visual feedback during agent processing.
- **Success Criteria**: Indicator shows correctly when agent is thinking or using tools.

### PHASE 14: API INTEGRATION (Estimated Time: 30 mins)
- **Task**: Create `api.ts` service with `sendMessage()`, `sendSelectionQuery()` functions.
- **Task**: Use `axios` or `fetch` with retry logic.
- **Task**: Implement error handling for API calls.
- **Task**: Configure API URL via environment variables.
- **Task**: Test API calls for basic functionality.
- **Deliverables**: Frontend service for interacting with backend API.
- **Success Criteria**: Frontend can successfully send requests and receive responses from the backend.

### PHASE 15: TEXT SELECTION FEATURE (Estimated Time: 45 mins)
- **Task**: Create `TextSelectionHandler.tsx`.
- **Task**: Implement `mouseup` event listener for `window.getSelection()`.
- **Task**: Display "Ask AI about this section" tooltip for text > 10 chars.
- **Task**: Implement tooltip positioning and click action (open chat with selected text).
- **Task**: Handle edge cases (empty selection, cross-page).
- **Deliverables**: Interactive text selection feature.
- **Success Criteria**: User can select text, trigger tooltip, and query agent contextually.

### PHASE 16: STATE MANAGEMENT (Estimated Time: 30 mins)
- **Task**: Create `ChatContext.tsx` with `React Context`.
- **Task**: Define and manage state: `messages`, `isOpen`, `isLoading`, `sessionId`, `selectedText`.
- **Task**: Implement provider/consumer pattern for chat state.
- **Deliverables**: Centralized state management for chat.
- **Success Criteria**: Chat components share and update state consistently.

### PHASE 17: BACKEND DEPLOYMENT (Estimated Time: 45 mins)
- **Task**: Choose deployment platform (Railway or Render).
- **Task**: Create `Dockerfile` (if containerization is chosen).
- **Task**: Configure environment variables on chosen platform.
- **Task**: Deploy backend application.
- **Task**: Test deployed API endpoints.
- **Task**: Get production API URL.
- **Deliverables**: Deployed and accessible backend API.
- **Success Criteria**: Deployed backend is fully functional and responsive.

### PHASE 18: FRONTEND DEPLOYMENT (Estimated Time: 30 mins)
- **Task**: Update frontend API URL to production backend URL.
- **Task**: Build Docusaurus site: `npm run build`.
- **Task**: Deploy Docusaurus site to GitHub Pages or Vercel.
- **Task**: Test chat on production site.
- **Task**: Verify CORS configuration.
- **Deliverables**: Deployed and accessible Docusaurus site with integrated chat.
- **Success Criteria**: Production frontend works end-to-end with the deployed backend.

### PHASE 19: TESTING & DEBUGGING (Estimated Time: 45 mins)
- **Task**: Thoroughly test all user flows (ask questions, text selection, multi-turn conversations).
- **Task**: Test mobile responsiveness of the chat UI.
- **Task**: Debug and fix any bugs found.
- **Task**: Test error scenarios (e.g., API failures, invalid input).
- **Task**: Verify source citations work and link correctly.
- **Deliverables**: Robust and bug-free chat feature.
- **Success Criteria**: All specified user flows and error scenarios are handled correctly.

### PHASE 20: POLISH & OPTIMIZATION (Estimated Time: 30 mins)
- **Task**: Improve UI/UX polish (animations, transitions).
- **Task**: Add loading skeletons for better perceived performance.
- **Task**: Optimize frontend and backend response times.
- **Task**: Implement rate limiting on backend if not already present.
- **Task**: Perform final comprehensive testing.
- **Task**: Document any remaining assumptions or future work.
- **Deliverables**: Highly polished and optimized RAG Chatbot.
- **Success Criteria**: Chatbot delivers a smooth, fast, and professional user experience.

TOTAL TIME ESTIMATE: ~12-14 hours
(Can be reduced with focused execution: ~8-10 hours)

CRITICAL PATH:
Phase 1-8 (Backend) → Phase 9-16 (Frontend) → Phase 17-18 (Deployment) → Phase 19-20 (Testing)

PARALLEL WORK POSSIBLE:
- Frontend components (9-13) can be built while backend endpoints (6-8) are being tested (Phase 9-13 vs Phase 6-8).
- Different content writing tasks within content creation phases.